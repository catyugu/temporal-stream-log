# 项目名称：TemporalStreamLog - 高性能时序日志聚合分析引擎

## 项目总览

你将构建一个日志系统的核心部分：一个中心聚合器（Aggregator）。它通过UDP接收来自不同“客户端”的结构化日志，将其高效地写入磁盘，并提供一个基于TCP的交互式查询端口，允许用户对近期日志进行实时分析。

## 项目要求说明

### **迭代 0: 项目初始化与现代CMake (预计用时: 1小时)**

* **功能要求:**
    1. 建立支持 C++20 的 CMake 项目。
    2. 组织目录结构，例如 `src` (源码), `include` (头文件), `tests` (测试)。
    3. 编写一个 `main` 函数，打印项目启动信息。

* **底层原理 / 高级特性:**
  * **CMake:** 学习 `target_include_directories` 来管理头文件路径，为后续模块化做准备。
  * **C++:** 确保 C++20 工具链就绪。

* **cppreference 学习重点:**
  * 浏览 `std::source_location` (C++20) 的介绍，思考它在日志系统中的潜在应用（自动获取文件名和行号）。

* **测试指南:**
  * 项目能被成功编译和链接。
  * 运行可执行文件后，输出预设的欢迎信息。

---

### **迭代 1: 核心数据结构与内存缓冲区 (预计用时: 1.5小时)**

* **功能要求:**
    1. 定义一个 `LogEntry` 结构体，至少包含：`timestamp` (时间戳), `level` (日志级别), `message` (日志消息)。
    2. 创建一个线程安全的、固定容量的内存缓冲区（例如 `LogBuffer` 类），用于暂存 `LogEntry`。当缓冲区满时，可以简单丢弃最旧的日志。

* **底层原理 / 高级特性:**
  * **数据结构:** `std::deque` 是一个很好的缓冲区选择，因为它支持高效的头尾插入/删除。
  * **高效率:** `LogEntry` 的 `message` 字段使用 `std::string`，但接收时可考虑 `std::string_view` 避免拷贝。
  * **时间处理:** 精确的时间戳是时序数据的核心。

* **cppreference 学习重点:**
  * **`<chrono>`**: `std::chrono::system_clock`, `time_point`。这是本次项目的核心标准库之一。
  * **`<deque>`**: 双端队列。
  * **`enum class`**: 用于强类型的日志级别 (e.g., `INFO`, `WARN`, `ERROR`)。
  * **`<mutex>`**, **`<lock_guard>`**: 保证缓冲区线程安全。

* **测试指南:**
    1. 编写单元测试（或在 `main` 中测试），创建多个线程同时向 `LogBuffer` 写入日志。
    2. 验证在高并发写入下，缓冲区大小不会超过预设值，且程序不会崩溃。

---

### **迭代 2: UDP 日志接收器 (预计用时: 1.5小时)**

* **功能要求:**
    1. 创建一个UDP服务器，监听指定端口（例如 8888）。
    2. 接收UDP数据包，将其内容解析为一条简单的日志消息，包装成 `LogEntry` 并存入迭代1中创建的 `LogBuffer`。

* **底层原理 / 高级特性:**
  * **网络:** 理解UDP与TCP的区别（无连接、不可靠、基于数据报）。这是一种全新的网络模型。
  * **系统调用:** `socket(AF_INET, SOCK_DGRAM, ...)`，`bind`，`recvfrom`。

* **cppreference 学习重点:**
  * 继续使用 C-style socket API 来理解底层。
  * **`<string_view>` (C++17)**: `recvfrom` 接收到的是一个字符数组，用 `string_view` 包装它可以避免立即构造 `std::string`，实现零拷贝解析。

* **测试指南:**
    1. 启动你的 `TemporalStreamLog` 服务器。
    2. 在另一个终端，使用 `netcat` 的UDP模式发送日志: `echo "My test log message" | nc -u -w0 localhost 8888`。
    3. 在服务器端打印接收到的日志，确认其已被正确存入缓冲区。

---

### **迭代 3: 异步磁盘写入器与文件系统 (预计用时: 2小时)**

* **功能要求:**
    1. 创建一个后台工作线程，专门负责将内存缓冲区 (`LogBuffer`) 的数据持久化到磁盘文件。
    2. 工作线程应定期（例如每秒）或当缓冲区数据达到一定阈值时被唤醒。
    3. 实现优雅关闭：主线程退出时，应通知工作线程将缓冲区内剩余数据全部刷盘后再退出。

* **底层原理 / 高级特性:**
  * **并发模型:** 经典的“生产者-消费者”模型。网络线程是生产者，磁盘线程是消费者。
  * **线程同步:** 如何在不使用忙等待（busy-waiting）的情况下唤醒工作线程。
  * **文件I/O:** C++标准库的文件流操作。

* **cppreference 学习重点:**
  * **`<filesystem>` (C++17)**: 用于创建日志目录、管理日志文件名（例如 `app-2025-09-05.log`）。
  * **`<fstream>`**: `std::ofstream` 用于写入文件。
  * **`<condition_variable>`**: 实现高效的线程等待/通知机制，这是高级并发编程的基石。
  * **`<jthread>` (C++20)**: `std::jthread` 支持自动 `join` 和中断请求，非常适合实现优雅关闭。

* **测试指南:**
    1. 启动服务器，通过UDP发送几十条日志。
    2. 检查项目目录下是否生成了日志文件，并且内容正确。
    3. 关闭服务器（Ctrl+C），检查所有已发送的日志是否都已写入文件。

---

### **迭代 4: 二进制序列化 (预计用时: 1.5小时)**

* **功能要求:**
    1. 设计一个简单的二进制格式来序列化 `LogEntry`，取代纯文本传输。格式可以很简单：`[8字节时间戳][1字节级别][2字节消息长度][消息内容]`。
    2. 修改UDP接收器，按二进制格式进行反序列化。
    3. 提供一个简单的客户端示例或测试代码，用于按此格式发送日志。

* **底层原理 / 高级特性:**
  * **数据表示:** 理解二进制数据的高效性（紧凑、解析快）。
  * **序列化/反序列化:** 将内存中的对象与字节流进行相互转换。

* **cppreference 学习重点:**
  * **`<span>` (C++20)**: 用于安全地表示和操作原始内存块，是处理网络数据包和序列化的现代利器。
  * **`<bit>` (C++20)**: `std::endian` 用于判断字节序，`std::bit_cast` 用于类型双关（type punning）而不会破坏严格别名规则（strict aliasing rules）。

* **测试指南:**
    1. 编写一个测试程序，它构建一个 `LogEntry`，序列化为字节数组，再反序列化回来，断言数据不变。
    2. 使用该程序向服务器发送二进制格式的UDP包，验证服务器能正确解析并存储。

---

### **迭代 5: C++20协程与范围库的交互式查询 (预计用时: 2.5小时 - 本迭代较有挑战)**

* **功能要求:**
    1. 在另一个端口上（例如 9999）启动一个TCP服务器。
    2. 该服务器使用C++20协程处理客户端连接，以极低的资源消耗支持多个并发查询。
    3. 实现一个简单的查询语言，例如：
        * `COUNT <level>`: 返回内存缓冲区中特定级别的日志数量。
        * `FIND <keyword>`: 返回包含特定关键词的日志。
    4. 使用C++20的范围库（Ranges）来执行查询操作，代码会非常优雅。

* **底层原理 / 高级特性:**
  * **异步I/O:** 使用协程将异步网络代码写出同步的逻辑。
  * **数据处理:** 函数式编程风格的数据过滤和转换。

* **cppreference 学习重点:**
  * **`<coroutine>`**: `co_await`, `co_return` 等。你需要一个简单的协程网络库（如asio）或者自己实现一个极简的awaiter。
  * **`<ranges>`**: `std::views::filter`, `std::views::transform` 等视图（views）和算法。这是C++20的另一大亮点。例如，`FIND` 命令的核心逻辑可能是一行代码：`auto results = log_buffer | std::views::filter(...) | std::views::take(10);`。

* **测试指南:**
    1. 先用UDP发送一些不同级别的日志。
    2. 使用 `netcat` 或 `telnet` 连接到 9999 端口。
    3. 输入 `COUNT INFO`，验证返回的数字是否正确。
    4. 输入 `FIND error`，验证返回的日志是否都包含 "error" 关键字。

这个 **TemporalStreamLog** 项目不仅能覆盖你所有的学习目标，而且最终的产出物是一个更酷、更具挑战性、也更能体现现代C++威力的系统。祝你玩得开心！
